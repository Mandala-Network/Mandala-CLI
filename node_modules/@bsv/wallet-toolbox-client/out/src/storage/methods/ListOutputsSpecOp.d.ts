import { ListOutputsResult, Validation } from '@bsv/sdk';
import { StorageProvider } from '../StorageProvider';
import { AuthId } from '../../sdk/WalletStorage.interfaces';
import { TableOutput } from '../schema/tables/TableOutput';
export interface ListOutputsSpecOp {
    name: string;
    useBasket?: string;
    ignoreLimit?: boolean;
    includeOutputScripts?: boolean;
    includeSpent?: boolean;
    /**
     * If true, and supported by storage, maximum performance optimization, computing balance done in the query itself.
     */
    totalOutputsIsSumOfSatoshis?: boolean;
    resultFromTags?: (s: StorageProvider, auth: AuthId, vargs: Validation.ValidListOutputsArgs, specOpTags: string[]) => Promise<ListOutputsResult>;
    resultFromOutputs?: (s: StorageProvider, auth: AuthId, vargs: Validation.ValidListOutputsArgs, specOpTags: string[], outputs: TableOutput[]) => Promise<ListOutputsResult>;
    filterOutputs?: (s: StorageProvider, auth: AuthId, vargs: Validation.ValidListOutputsArgs, specOpTags: string[], outputs: TableOutput[]) => Promise<TableOutput[]>;
    /**
     * undefined to intercept no tags from vargs,
     * empty array to intercept all tags,
     * or an explicit array of tags to intercept.
     */
    tagsToIntercept?: string[];
    /**
     * How many positional tags to intercept.
     */
    tagsParamsCount?: number;
}
/**
 * Check basket and tags arguments passed to listOutputs to determine if they trigger a special operation execution mode.
 * @param basket
 * @param tags
 * @returns
 */
export declare function getListOutputsSpecOp(basket: string, tags: string[]): {
    specOp: ListOutputsSpecOp | undefined;
    basket?: string;
    tags: string[];
};
//# sourceMappingURL=ListOutputsSpecOp.d.ts.map