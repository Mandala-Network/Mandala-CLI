"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Brc29RemittanceModule = exports.DefaultLockingScriptProvider = exports.DefaultNonceProvider = void 0;
const createNonce_js_1 = require("../../auth/utils/createNonce.js");
const P2PKH_js_1 = __importDefault(require("../../script/templates/P2PKH.js"));
const PublicKey_js_1 = __importDefault(require("../../primitives/PublicKey.js"));
/**
 * Default nonce provider using SDK createNonce.
 */
exports.DefaultNonceProvider = {
    async createNonce(wallet, scope, originator) {
        const origin = originator;
        return await (0, createNonce_js_1.createNonce)(wallet, scope, origin);
    }
};
/**
 * Default locking script provider using SDK P2PKH template.
 */
exports.DefaultLockingScriptProvider = {
    async pubKeyToP2PKHLockingScript(publicKey) {
        const address = PublicKey_js_1.default.fromString(publicKey).toAddress();
        return new P2PKH_js_1.default().lock(address).toHex();
    }
};
/**
 * BRC-29-based remittance module.
 * - payer creates a payment action to a derived P2PKH output
 * - payer sends { tx, derivationPrefix, derivationSuffix } as settlement artifact
 * - payee internalizes the tx output using wallet.internalizeAction
 * - optional rejection can include a refund token embedded in the termination details
 */
class Brc29RemittanceModule {
    constructor(cfg = {}) {
        this.id = 'brc29.p2pkh';
        this.name = 'BSV (BRC-29 derived P2PKH)';
        this.allowUnsolicitedSettlements = true;
        // BRC-29 Protocol.
        this.protocolID = cfg.protocolID ?? [2, '3241645161d8'];
        this.labels = cfg.labels ?? ['brc29'];
        this.description = cfg.description ?? 'BRC-29 payment';
        this.outputDescription = cfg.outputDescription ?? 'Payment for remittance invoice';
        this.refundFeeSatoshis = cfg.refundFeeSatoshis ?? 1000;
        this.minRefundSatoshis = cfg.minRefundSatoshis ?? 1000;
        this.internalizeProtocol = cfg.internalizeProtocol ?? 'wallet payment';
        this.nonceProvider = cfg.nonceProvider ?? exports.DefaultNonceProvider;
        this.lockingScriptProvider = cfg.lockingScriptProvider ?? exports.DefaultLockingScriptProvider;
    }
    async buildSettlement(args, ctx) {
        const { wallet, originator } = ctx;
        let option;
        try {
            option = ensureValidOption(args.option);
        }
        catch (error) {
            const message = error instanceof Error ? error.message : String(error);
            return terminate('brc29.invalid_option', message);
        }
        const amountSatoshis = option.amountSatoshis;
        const origin = originator;
        try {
            // Create per-payment derivation values.
            const derivationPrefix = await this.nonceProvider.createNonce(wallet, 'self', origin);
            const derivationSuffix = await this.nonceProvider.createNonce(wallet, 'self', origin);
            // Derive payee public key.
            const protocolID = option.protocolID ?? this.protocolID;
            const keyID = `${derivationPrefix} ${derivationSuffix}`;
            const { publicKey } = await wallet.getPublicKey({
                protocolID,
                keyID,
                counterparty: option.payee
            }, origin);
            if (typeof publicKey !== 'string' || publicKey.trim() === '') {
                return terminate('brc29.public_key_missing', 'Failed to derive payee public key for BRC-29 settlement.');
            }
            const lockingScript = await this.lockingScriptProvider.pubKeyToP2PKHLockingScript(publicKey);
            if (typeof lockingScript !== 'string' || lockingScript.trim() === '') {
                return terminate('brc29.locking_script_missing', 'Failed to produce P2PKH locking script.');
            }
            const action = await wallet.createAction({
                description: option.description ?? this.description,
                labels: option.labels ?? this.labels,
                outputs: [
                    {
                        satoshis: amountSatoshis,
                        lockingScript,
                        customInstructions: JSON.stringify({
                            derivationPrefix,
                            derivationSuffix,
                            payee: option.payee,
                            threadId: args.threadId,
                            note: args.note
                        }),
                        outputDescription: this.outputDescription
                    }
                ],
                options: {
                    randomizeOutputs: false
                }
            }, origin);
            const tx = action.tx ?? action.signableTransaction?.tx;
            if (tx == null) {
                return terminate('brc29.missing_tx', 'wallet.createAction did not return a transaction.');
            }
            if (!isAtomicBeef(tx)) {
                return terminate('brc29.invalid_tx', 'wallet.createAction returned an invalid transaction payload.');
            }
            return {
                action: 'settle',
                artifact: {
                    customInstructions: { derivationPrefix, derivationSuffix },
                    transaction: tx,
                    amountSatoshis: option.amountSatoshis,
                    outputIndex: option.outputIndex ?? 0
                }
            };
        }
        catch (error) {
            const message = error instanceof Error ? error.message : String(error);
            return terminate('brc29.build_failed', `BRC-29 settlement failed: ${message}`);
        }
    }
    async acceptSettlement(args, ctx) {
        const { wallet, originator } = ctx;
        const origin = originator;
        console.log('acceptSettlement', args);
        try {
            const settlement = ensureValidSettlement(args.settlement);
            const outputIndex = settlement.outputIndex ?? 0;
            debugger;
            const internalizeResult = await wallet.internalizeAction({
                tx: settlement.transaction,
                outputs: [
                    {
                        paymentRemittance: {
                            derivationPrefix: settlement.customInstructions.derivationPrefix,
                            derivationSuffix: settlement.customInstructions.derivationSuffix,
                            senderIdentityKey: args.sender
                        },
                        outputIndex,
                        protocol: this.internalizeProtocol
                    }
                ],
                labels: this.labels,
                description: 'BRC-29 payment received'
            }, origin);
            return { action: 'accept', receiptData: { internalizeResult } };
        }
        catch (error) {
            const message = error instanceof Error ? error.message : String(error);
            return terminate('brc29.internalize_failed', `Failed to internalize BRC-29 settlement: ${message}`);
        }
    }
}
exports.Brc29RemittanceModule = Brc29RemittanceModule;
function terminate(code, message, details) {
    return { action: 'terminate', termination: { code, message, details } };
}
function ensureValidOption(option) {
    if (option == null || typeof option !== 'object') {
        throw new Error('BRC-29 option terms are required');
    }
    const amountSatoshis = option.amountSatoshis;
    if (!Number.isInteger(amountSatoshis) || amountSatoshis <= 0) {
        throw new Error('BRC-29 option amount must be a positive integer');
    }
    const outputIndex = option.outputIndex;
    if (outputIndex != null && (!Number.isInteger(outputIndex) || outputIndex < 0)) {
        throw new Error('BRC-29 option outputIndex must be a non-negative integer');
    }
    const protocolID = option.protocolID;
    if (protocolID != null) {
        if (!Array.isArray(protocolID) || protocolID.length !== 2) {
            throw new Error('BRC-29 option protocolID must be a tuple [number, string]');
        }
        const [protocolNumber, protocolString] = protocolID;
        if (!Number.isInteger(protocolNumber) || protocolNumber < 0 || !isNonEmptyString(protocolString)) {
            throw new Error('BRC-29 option protocolID must be a tuple [number, string]');
        }
    }
    const labels = option.labels;
    if (labels != null && (!Array.isArray(labels) || labels.some((label) => !isNonEmptyString(label)))) {
        throw new Error('BRC-29 option labels must be a list of non-empty strings');
    }
    const description = option.description;
    if (description != null && !isNonEmptyString(description)) {
        throw new Error('BRC-29 option description must be a non-empty string');
    }
    return option;
}
function ensureValidSettlement(settlement) {
    if (settlement == null || typeof settlement !== 'object') {
        throw new Error('BRC-29 settlement artifact is required');
    }
    const instructions = settlement.customInstructions;
    if (instructions == null || typeof instructions !== 'object') {
        throw new Error('BRC-29 settlement requires customInstructions');
    }
    if (!isNonEmptyString(instructions.derivationPrefix) || !isNonEmptyString(instructions.derivationSuffix)) {
        throw new Error('BRC-29 settlement derivation values are required');
    }
    const amountSatoshis = settlement.amountSatoshis;
    if (!Number.isInteger(amountSatoshis) || amountSatoshis <= 0) {
        throw new Error('BRC-29 settlement amount must be a positive integer');
    }
    const outputIndex = settlement.outputIndex;
    if (outputIndex != null && (!Number.isInteger(outputIndex) || outputIndex < 0)) {
        throw new Error('BRC-29 settlement outputIndex must be a non-negative integer');
    }
    if (!isAtomicBeef(settlement.transaction)) {
        throw new Error('BRC-29 settlement transaction must be a non-empty byte array');
    }
    return settlement;
}
function isAtomicBeef(tx) {
    if (!Array.isArray(tx) || tx.length === 0)
        return false;
    return tx.every((byte) => Number.isInteger(byte) && byte >= 0 && byte <= 255);
}
function isNonEmptyString(value) {
    return typeof value === 'string' && value.trim().length > 0;
}
//# sourceMappingURL=BasicBRC29.js.map